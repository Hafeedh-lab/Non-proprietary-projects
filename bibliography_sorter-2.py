# -*- coding: utf-8 -*-
"""BIBLIOGRAPHY SORTER

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1rtH_vlCJ4OASGCfUhGyMhlH_VMG7hEyN
"""

from docx import Document
from docx.oxml import OxmlElement
from docx.oxml.ns import qn
from docx.shared import RGBColor

def add_hyperlink(paragraph, url, text, color="0000FF", underline=True):
    """
    A function that places a hyperlink within a paragraph object.
    """
    part = paragraph.part
    # Create a relationship id with the target url
    r_id = part.relate_to(url, "http://schemas.openxmlformats.org/officeDocument/2006/relationships/hyperlink", True)

    # Create the w:hyperlink element and set the relationship id
    hyperlink = OxmlElement('w:hyperlink')
    hyperlink.set(qn('r:id'), r_id)

    # Create a w:r element and its properties
    new_run = OxmlElement('w:r')
    rPr = OxmlElement('w:rPr')

    # Add color formatting
    c = OxmlElement('w:color')
    c.set(qn('w:val'), color)
    rPr.append(c)

    # Add underline formatting if desired
    if underline:
        u = OxmlElement('w:u')
        u.set(qn('w:val'), 'single')
        rPr.append(u)

    new_run.append(rPr)

    # Create a w:t element with the hyperlink text
    t = OxmlElement('w:t')
    t.text = text
    new_run.append(t)

    hyperlink.append(new_run)
    paragraph._p.append(hyperlink)
    return hyperlink

def copy_run_formatting(source_run, target_run):
    """Copy formatting from source run to target run"""
    if hasattr(source_run, 'bold'):
        target_run.bold = source_run.bold
    if hasattr(source_run, 'italic'):
        target_run.italic = source_run.italic
    if hasattr(source_run, 'underline'):
        target_run.underline = source_run.underline
    if hasattr(source_run, 'font'):
        if hasattr(source_run.font, 'color') and source_run.font.color:
            target_run.font.color.rgb = source_run.font.color.rgb
        if hasattr(source_run.font, 'name'):
            target_run.font.name = source_run.font.name
        if hasattr(source_run.font, 'size'):
            target_run.font.size = source_run.font.size

def extract_text_from_element(element):
    """Safely extract text from XML element"""
    if element.tag == qn('w:hyperlink'):
        # For hyperlinks, we need to get text from all runs inside
        text = ""
        for t_elem in element.xpath('.//w:t'):
            if t_elem.text is not None:
                text += t_elem.text
        return text
    elif element.tag == qn('w:r'):
        # For regular runs
        text = ""
        for t_elem in element.xpath('./w:t'):
            if t_elem.text is not None:
                text += t_elem.text
        return text
    else:
        # For other elements
        return ""

def copy_paragraph_with_formatting(source_para, target_doc):
    """Copy paragraph content with full formatting including hyperlinks"""
    target_para = target_doc.add_paragraph()

    # Process the paragraph elements
    processed_content = set()  # Track processed content to avoid duplicates

    # First, extract all hyperlinks and their relationship IDs
    hyperlinks = {}
    for element in source_para._element.xpath('.//w:hyperlink'):
        r_id = element.get(qn('r:id'))
        if r_id and r_id in source_para.part.rels:
            url = source_para.part.rels[r_id].target_ref
            text = extract_text_from_element(element)
            hyperlinks[id(element)] = {'url': url, 'text': text, 'element': element}

    # Handle direct runs and hyperlinks in correct order
    for child in source_para._element:
        if child.tag == qn('w:hyperlink'):
            # Process hyperlink
            child_id = id(child)
            if child_id in hyperlinks and hyperlinks[child_id]['text'] not in processed_content:
                link_info = hyperlinks[child_id]
                add_hyperlink(target_para, link_info['url'], link_info['text'])
                processed_content.add(link_info['text'])

        elif child.tag == qn('w:r'):
            # Process regular run
            run_text = extract_text_from_element(child)
            if run_text and run_text not in processed_content:
                # Create new run with the text
                new_run = target_para.add_run(run_text)

                # Copy formatting from original run
                source_run = None
                for run in source_para.runs:
                    if run.text == run_text:
                        source_run = run
                        break

                if source_run:
                    copy_run_formatting(source_run, new_run)
                else:
                    # Try to extract formatting from XML
                    rPr = child.find(qn('w:rPr'))
                    if rPr is not None:
                        if rPr.find(qn('w:b')) is not None:
                            new_run.bold = True
                        if rPr.find(qn('w:i')) is not None:
                            new_run.italic = True
                        if rPr.find(qn('w:u')) is not None:
                            new_run.underline = True

                processed_content.add(run_text)

    return target_para

def main():
    input_file = "Copy of bibliography-2.docx"
    output_file = "sorted_bibliography.docx"

    try:
        # Load the document
        doc = Document(input_file)

        # Get non-empty paragraphs with their objects
        paragraphs = [(para.text.strip(), para) for para in doc.paragraphs if para.text.strip()]

        # Remove duplicates based on text content
        unique_paragraphs = {}
        for text, para in paragraphs:
            if text.lower() not in unique_paragraphs:
                unique_paragraphs[text.lower()] = para

        # Sort the unique paragraphs alphabetically (case-insensitive)
        sorted_paragraphs = sorted(unique_paragraphs.items(), key=lambda x: x[0])

        # Create new document for sorted output
        new_doc = Document()

        # Add each paragraph to the new document with proper formatting
        for _, para in sorted_paragraphs:
            copy_paragraph_with_formatting(para, new_doc)

        # Save the new document
        new_doc.save(output_file)
        print(f"Processed {len(sorted_paragraphs)} unique references. Sorted output saved to '{output_file}'.")

    except Exception as e:
        print(f"Error processing document: {str(e)}")

if __name__ == "__main__":
    main()